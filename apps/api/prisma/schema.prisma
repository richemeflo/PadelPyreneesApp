// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * =======================
 * MODELS
 * =======================
 */

model Player {
  id           String   @id @default(cuid())
  email        String   @unique
  pseudo       String
  passwordHash String
  locale       String   @default("fr")
  lat          Float?
  lon          Float?
  elo          Int      @default(1000)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Back-relations vers Pair (2 relations nommées L et R)
  pairsAsA Pair[] @relation("L")
  pairsAsB Pair[] @relation("R")

  // Historique Elo
  ratingHistory RatingHistory[]

  @@index([elo])
}

model Club {
  id        String   @id @default(cuid())
  name      String
  logoUrl   String?
  address   String
  lat       Float
  lon       Float
  apiKind   String? // 'viapadel' | 'bruyeres' | 'manual' | ...
  apiKey    String?
  createdAt DateTime @default(now())

  // Back-relation vers Court
  courts Court[]

  // Tournois externes créés par le club (optionnel)
  tournamentsExternal Tournament[] @relation("ExternalClub")

  @@unique([name, address])
  @@index([lat, lon])
}

model Court {
  id   String @id @default(cuid())
  name String

  clubId String
  club   Club   @relation(fields: [clubId], references: [id])

  matches Match[]

  // Réservations éventuelles plus tard
  // reservations Reservation[]

  @@unique([clubId, name]) // un court "name" unique dans un club
  @@index([clubId])
}

model Pair {
  id String @id @default(cuid())

  lId String
  rId String
  l   Player @relation("L", fields: [lId], references: [id])
  r   Player @relation("R", fields: [rId], references: [id])

  elo Int @default(1000)

  // Back-relations depuis Match (si on veut interroger depuis Pair)
  matchesAsA Match[] @relation("PairA")
  matchesAsB Match[] @relation("PairB")

  @@unique([lId, rId]) // empêche de créer deux fois la même paire
  @@index([lId])
  @@index([rId])
}

model Match {
  id String @id @default(cuid())

  pairAId String
  pairBId String
  pairA   Pair   @relation("PairA", fields: [pairAId], references: [id])
  pairB   Pair   @relation("PairB", fields: [pairBId], references: [id])

  courtId String?
  court   Court?  @relation(fields: [courtId], references: [id])

  startsAt  DateTime
  score     String?
  status    String   @default("PENDING") // PENDING|CONFIRMED|DISPUTED
  createdAt DateTime @default(now())

  ratingHistory RatingHistory[]

  @@index([pairAId])
  @@index([pairBId])
  @@index([courtId])
  @@index([startsAt])
}

model RatingHistory {
  id       String @id @default(cuid())
  playerId String
  player   Player @relation(fields: [playerId], references: [id])

  matchId String
  match   Match  @relation(fields: [matchId], references: [id])

  before    Int
  after     Int
  delta     Int
  createdAt DateTime @default(now())

  @@index([playerId])
  @@index([matchId])
}

model Tournament {
  id String @id @default(cuid())

  // kind: 'internal' | 'external'
  kind String

  // INTERNAL: créé par un admin (stocke son id si besoin), EXTERNAL: par un club
  createdBy String?

  // Relation vers Club si EXTERNAL
  externalClubId String?
  externalClub   Club?   @relation("ExternalClub", fields: [externalClubId], references: [id])

  name     String
  desc     String?
  levelMin Int?
  levelMax Int?
  startsAt DateTime
  endsAt   DateTime
  place    String?
  price    Int?

  @@index([kind])
  @@index([externalClubId])
  @@index([startsAt])
}
